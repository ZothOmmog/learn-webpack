ссылка на видео: https://youtu.be/eSaF8NXeNsA

Изучить:
    1. addEventListener 9:43
    2. removeEventListener 10:44
    3. Добавление в объект window 11:35
    4. Метод node.js require('path') 24:40
    5. eval() компиляция строк в js 27:35
!!! 6. РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ JS 56:20 !!!
    7. Динамическое добавление css в head html 59:03
    8. Назначение второго файла vendors 1:33:05
    9. В чем разница между react и react-dom?
    10. eslint 2:36:36

Для чего:
    1. Некомфортно подключать самостоятельно скрипты в html, если приложение большое (надо следить, чтобы всё было в правильном порядке)

На заметку:
    1. webpack.js.org/configuration всё о webpack.config.js, в частности можно смотреть паттерны имён для решения различных проблем
    2. Вебпак имеет множество плагинов - встоенных и тех, которые надо загружать отдельно
        2.1 html-webpack-plugin помогает взаимодействовать с html
        2.2 clean-webpack-plugin очищает папку с билдом для того, чтобы там не было файлов с разным хешем
    3. По умолчанию webpack работает только с js, для того, чтобы он начал работать с другими типами данных надо подключать "loader'ы"
        3.1 При работе с лоадерами вебпак пропускает данные справа на лево, поэтому указываем сначала style-loader, а потом css-loader
        3.2 Примеры лоадеров:
            3.2.1 css-loader позволяет импортировать css в js
            3.2.1 style-loader добавляет стили css в head html (добавление происходит динамически)
    4. Чтобы не писать постоянно .js или .json можно подключить extensions 1:21:40
    5. Чтобы не указывать постоянно относительные пути с большой вложенностью можно использовать alias 1:24:02
    6. Одна библиотека может импортироваться в разные файлы, которые относятся к разным точкам входа, чтобы не загружать её несколько раз есть свойство optimization
       В нём есть свойство splitChunks, а в нём chunks, если там указать 'all', то общий код будет выноситься в общие файлы (vendors), в данном случае выносится jquery
    7. Для devServer'a есть webpack-dev-server
    8. webpack-dev-server все файлы хранит в оперативной памяти, за счёт этого быстрее всё обновляется и поэтому всё пропадает из папки dist
    9. Для того, чтобы копировать файлы в продакшн есть плагин copy-webpack-plugin (есть проблемы с кешем, про это в видео не говорится)
    10. mini-css-extract-plugin предоставляет класс для плагина и статическое поле для loader'а. Плагин позволяет выносить css в отдельный файл
        10.1 hot-module-replacement позволяет менять некоторые вещи без перезагрузки страницы, полезно для разработки
            10.1.1 Для того, чтобы было активно только в разработке создаем переменную isDev (через process.env получаем доступ к переменным окружения)
                10.1.1.1 Переменную isDev можно использовать для той же цели для дев-сервера
            10.1.2 Для задания переменной окружения используем пакет cross-env, чтобы не зависеть от ОС при её создании (пакет сам определяет ОС и задает переменные)
        10.2
    11. Для минификации хтмл добавляем minify: {collapseWhiteSpace: true} в плагин html-webpack-plugin, можно использовать вместе с isDev
    12. terser-webpack-plugin для оптимизации js
    13. optimize-css-assets-webpack-plugin для оптимизации (в частности минификации) css
    14. Оба плагина подключаются в optimization через поле minimizer
    15. Чтобы работать с css-препроцессорами просто подключаем соответствующий лоадер, а дальше поток аналогичный для простого css
    16. Для работы с bablel необходимо установить соответствующий лоадер, а так же пресеты к нему в зависимости от того, какие фичи языка нужны
    17. Для того, чтобы оптимизировать транспиляцию кода можно применить "browserslist": "> 0.25%, not dead" в package.json
    18. Для корректной работы с async/await необходимо подключить полифил, как доп. либу и юзать его вместе с index.js
    19. Для поддержки статических полей в классах нужен @babel/plugin-proposal-class-properties
    20. Для работы с ts есть пресет '@babel/preset-typescript', его можно собрать самому из плагинов
    21. devTool позволяет получать исходные карты и т.д. sourse-map исходные карты, позволяют получить доступ к тому, как всё выглядело до компиляции
    22. eslint-loader
    23. lodash позвояет использовать lazy-loading, (не стал использовать, т.к. в реакте есть что-то похожее)
    24. webpack-bundle-analyzer предоставляет возможности для оптимизации
        24.1 Можно добавить скрипт, через который можно посмотреть то же самое.
    